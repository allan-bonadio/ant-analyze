//
// blanket plot - a WebGL helper library to draw a blanket plot.
//					basically, a surface z = f(x, y), like that.
//
/* eslint-disable eqeqeq, no-throw-literal  */

import {extent} from 'd3-array';
import {scaleLinear} from 'd3-scale';
import {hsl} from 'd3-color';

import {mat4, vec4} from 'gl-matrix';

import {vertexBuffer} from './genComplex';
import blanketTriangles from './blanketTriangles';
import {blanketAxes, weatherVane} from './blanketAxes';
import {axisTicsPainter} from './AxisTics';
import Webgl3D from '../Webgl3D';


// don't try to type these names, just copy paste
const π = Math.PI, π_2 = Math.PI/2, twoπ = Math.PI * 2;  // ②π

/*   Guide to Coordinate Systems

science coords: the ideal numbers used as the ranges and domains of the variables 
	in the demo.  Convert to cell coords with Webgl3D.xScale(), .yScale() and 
	.zScale(), or .scaleXYZ() for vectors.
	The real and imaginary parts of the indep var become the x and y coordinate.
	The complex result of the function becomes the z and lightness coordinates.

cell coords:The xy plane is broken into 'cells' with vertices at the corners.
	So if you have 5 cells by 8 cells, that's 6 vertices by 9 vertices.
	Cell coords start at 0, 0 and only go positive.
	The buffer's arrays are filled with cell coordinate numbers.
	Integer values are cell boundaries, and typically the only values we use for vertices.
	The size of the cell space rectangle comes from WebGL3d's TARGET_CELLS and the domains;
	may change in the future.  
	There are no cells along the Z axis: whole range mapped to 0...1.

clip coords: The gl drawing space is actually -1...1 inclusive for x y and z.
	Convert from cell coords using the matrices generated by createMatrices().
	This is done in the vertex shader with projectionMatrix and modelViewMatrix.
	modelViewMatrix includes the rotations from longitude and latitude.

canvas coords: If your canvas is 700 x 500, these coords traverse 
	from 0...700,  and 0...500 .
	This is done by webgl itself.
*/




/* *************************************************** blanketPlot */
// call them like this:
//    create it, passing a Canvas element, and how big
//		let plot = new blanketPlot(
// 			document.getElementById('blanket-plot'),
// 			{nXCells: xxxx, nYCells:xxx, ...});
// 
//      plot.attachData(blanketData);

// class to talk to graphics processor via webgl.  This doesn't touch science coordinates,
// just cell coordinates and cellsize in viewable space
class blanketPlot {
	// canvas is the canvas DOM node
	// nXCells and nYCells is dimensions of blanket area in cell coords
	// options: nXCells, nYCells = cell dimensions of xy area
	// xPerCell, yPerCell, zPerCell = size of a cell in science space
	constructor(canvas, options) {
		this.canvas = canvas;
		Object.assign(this, options);
		
		// these set up for the geometry, and calculate number of vertices they need
		// for each set of graphical things they draw
		this.axes = new blanketAxes(this);
		this.triangles = new blanketTriangles(this);
		this.axisTics = new axisTicsPainter(this, Webgl3D.me);
		
		this.painters = [
			this.triangles, 
			this.axes, 
			new weatherVane(this),  // optional; a diagnostic
			this.axisTics,
		];

		this.maxVertices = this.painters.reduce((sum, painter) => sum + painter.maxVertices, 0);

		// set up and make sure gl is possible
		this.gl = canvas.getContext('webgl') || 
					canvas.getContext('experimental-webgl');

		// If it can't do GL, give up now
		if (!this.gl) {
			throw new Error("Unable to initialize WebGL. "+ 
				"Your browser or machine may not support it.");
		}

		// stuff to be done once
		this.initShaderProgram();

		this.then = 0;
	}
	
	// check for a WebGL error.  This is taken out of some documentation.
	checkOK() {
		let gl = this.gl;
		if (! gl)
			return;  // doesn't exist yet
			
		let err = gl.getError();
		if (err) {
			let msg = '';
			switch (err) {
			case gl.INVALID_ENUM:
				msg = "Bad enumerated argument.";
				break;
			case gl.INVALID_VALUE:
				msg = "Numeric argument out of range.";
				break;
			case gl.INVALID_OPERATION:
				msg = "Command is not allowed for the current state.";
				break;
			case gl.INVALID_FRAMEBUFFER_OPERATION:
				msg = "Current framebuffer is not complete.";
				break;
			case gl.OUT_OF_MEMORY:
				msg = "Out of Memory.";
				break;
			case gl.CONTEXT_LOST_WEBGL:
				msg = "WebGL context was lost.";
				break;
			default:
				msg = "Unknown error from GL: "+ err;
			}
			console.error("error from webgl: ", msg);
		}
	}

	//********************************************************* Programs


	// Initialize a shader program, so WebGL knows how to draw our data
	initShaderProgram() {
		let gl = this.gl;

		// Vertex shader program
		const vsSource = `
			attribute vec4 aVertexPosition;
			attribute vec4 aVertexColor;

			uniform mat4 uCompositeMatrix;

			varying lowp vec4 vColor;

			void main() {
				gl_Position = uCompositeMatrix 
					* aVertexPosition;
				vColor = aVertexColor;

				gl_PointSize = 10.;  // dot size, actually a crude square
				// diagnostic: change to POINTS in blanketTriangle's draw method
			}
		`;

		// Fragment shader program
		const fsSource = `
			varying lowp vec4 vColor;

			void main(void) {
				gl_FragColor = vColor;
			}
		`;

		// creates shader from source and compiles it.
		function loadShader(gl, type, source) {
			const shader = gl.createShader(type);
			gl.shaderSource(shader, source);
			gl.compileShader(shader);

			// See if it compiled successfully
			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				let err = gl.getShaderInfoLog(shader);
				gl.deleteShader(shader);
				throw new Error('An error occurred compiling the shaders: '+ err);
			}

			return shader;
		}

		const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
		const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

		// Create the shader program
		const shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);

		// If creating the shader program failed, alert
		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			throw new Error("Unable to initialize the shader program: " + 
				gl.getProgramInfoLog(shaderProgram));
		}

		this.shaderProgram = shaderProgram;
		this.createProgramInfo();
	}

	// Collect all the info needed to use the shader program.
	// Look up which attributes our shader program is using
	// for aVertexPosition, aVevrtexColor and also
	// look up uniform locations.
	createProgramInfo() {
		let gl = this.gl, sp = this.shaderProgram;
		
		this.programInfo = {
			program: this.shaderProgram,
			attribLocations: {
				vertexPosition: gl.getAttribLocation(sp, 'aVertexPosition'),
				vertexColor: gl.getAttribLocation(sp, 'aVertexColor'),
			},
			uniformLocations: {
				compositeMatrix: gl.getUniformLocation(sp, 'uCompositeMatrix'),
			},
		};

	}
	
	//********************************************************* Data Layout
	
	// list out ALL the vertices and their colors
	dumpBuffer() {
		
		console.log("actual data put into vertex buffer")
		this.painters.forEach(painter => 
			this.buffer.dump(painter.name, painter.startVertex, painter.nVertices));
	}

	
	// derive Z scaler from points calculated in calcPoints()
	// also lightness for complex
	// again, convert from dataspace coords to cell coords, use scale.invert for opposite
	// Blanket z values must be calculated by now!
	deriveZScale() {
		// find the unified extent of all of the z values on all rows
		// At this point there should be no z values that are objects
		let b = this.blanket;
		if (! b)
			throw "No Blanket Array in deriveScalers()";

		let mini = Infinity, maxi = -Infinity, mi, mx;
		let biggest = -Infinity, big, small;
		for (let f = 0; f < b.length; f++) {
			[mi, mx] = extent(b[f], d => d.z_science);
			[small, big] = extent(b[f], d => d.abs);
			//console.log(`mi=${mi} mx=${mx} from d.z=`, b[f].map(d => d.z_science));
			if (isNaN(mi + mx)) debugger;

			mini = Math.min(mi, mini);
			maxi = Math.max(mx, maxi);
			biggest = Math.max(big, biggest);
		}
		
		// that's min and max in science coords.  convert to cell coords.
		// but z values converted to 'cell coords' for webgl
		// note we're scaling z backwards
		this.zScale = scaleLinear()
			.domain([maxi, mini])
			.range([0, Webgl3D.me.nZCells]);  // it's 0...1
		this.zMin = mini;
		this.zMax = maxi;
		this.zPerCell = (maxi - mini) / this.nZCells;
		
		// must also be on the graph component
		// this way you can index the dimensions if you have to eg this[dimension +'Scale']
		let gr = Webgl3D.me;
		gr.zMin = this.zMin; gr.zMax = this.zMax; gr.zScale = this.zScale;

		// adjust the color algorithm for larger/smaller complex magnitudes
		// which determine lightness in the complex color
		this.lightnessScale = scaleLinear()
			.range([0, 1])
			.domain([0, biggest]);

		if (isNaN(this.zScale(1))) debugger;
	}
	
	// take a complex value for vert.z (like {re: 1, im: -1}) 
	// and fill in other components (color, height) to make the 3d complex graph
	// we always keep saturation at 100% for the complex plane
	complexScaleAndColor(vert, lightnessScale) {
		let zre = vert.z_data.re, zim = vert.z_data.im;
	
		let hue = 180 * Math.atan2(zim, zre) / Math.PI + 180;  // make it positive
		let lightness = Math.atan(lightnessScale(vert.abs)) * 2 / Math.PI;  // make it 0...1
	
		let rgb = hsl(hue, 1, lightness).rgb();
		vert.red = rgb.r / 255;
		vert.green = rgb.g / 255;
		vert.blue = rgb.b / 255;
		vert.z_science = zre;
		//console.log(`(${zre},${zim}) ---> `, vert);
	
		// check to see if ANY of these are NaN
		if (isNaN(zre + zim + hue + lightness + rgb.r + rgb.g + rgb.b)) debugger;
	}

	// call this after you've figured out the Z scaling from science coords to cell coords
	// zScale is a function that converts from z_data values to z cell coords
	scaleBlanket() {
		let blanket = this.blanket;
		let zScale = this.zScale;
		for (let y = 0; y <= blanket.nYCells; y++) {
			let row = blanket[y];
			for (let x = 0; x <= blanket.nXCells; x++) {
				let vert = row[x];
			
				if (typeof vert.z_data == 'object') {
					// a complex number - convert to z scalar, and color
					this.complexScaleAndColor(vert, this.lightnessScale);
					if (isNaN(vert.z_science + vert.red + vert.green)) debugger;
				}

				vert.z = zScale(vert.z_science);
			}
		}
	}

	// called by client to give the data, and generates the compact arrays
	// to be sent to the gpu
	// This is how you feed in your data.  blanket = nested JS arrays like
	//		[[el,el,el],[el,el,el],[el,el,el]]
	// Blanket must have same dimensions as passed to blanketPlot constrctor.
	// each value is an object like 
	// {x: 2.3, y: 4.5, z: 12.7, red: .4, green: .2, blue: .95, alpha: 1, ...misc}
	attachData(blanket) {
		this.buffer = new vertexBuffer(this.maxVertices);
		this.blanket = blanket;
		
		this.deriveZScale();
		this.scaleBlanket();
		
		// decide on the tics.  Must be after deriveZScale() but before layDownVertices()
		this.axisTics.generateAllTics();
	
		// each of these routines fills the arrays with data for different things being drawn
		this.painters.forEach(painter => painter.layDownVertices());

		//this.dumpBuffer();

		this.createProgramInfo();
		this.buffer.attachToGL(this.gl, this.programInfo.attribLocations);
	}

	//********************************************************* Draw One Frame
	
	// diagnostic: make sure these are ok
	verifyMatrices(compositeMatrix) {
		let graph = Webgl3D.me;
		
		console.log("verify all 8 corners of cell space");
		let vec = vec4.create(), out = vec4.create();
		vec[3] = 1;
		[0, graph.nXCells].forEach(x => {
			vec[0] = x;
			[0, graph.nYCells].forEach(y => {
				vec[1] = y;
				[0, graph.nZCells].forEach(z => {
					vec[2] = z;
					vec4.transformMat4(out, vec, compositeMatrix);
					console.log('%d %d %d =>', x, y, z, 
						(out[0]/out[3]).toFixed(2).padStart(6), 
						(out[1]/out[3]).toFixed(2).padStart(6), 
						(out[2]/out[3]).toFixed(2).padStart(6));
				});
			});
		});
	}
	
	// make the matrices that position and rotate it all into view
	createMatrices(longitude, latitude) {
		let gl = this.gl;

		// note: gl-matrix.js always has the first argument
		// as the destination to receive the result.

		// Create a perspective matrix, a special matrix that is
		// used to simulate the distortion of perspective in a camera.
		// Our field of view is 45 degrees, with a width/height
		// ratio that matches the display size of the canvas
		// and we only want to see objects between whatever units
		// away from the camera.
		const projectionMatrix = mat4.create();
		mat4.perspective(projectionMatrix,
			 45 * Math.PI / 180,
			 gl.canvas.clientWidth / gl.canvas.clientHeight,
			 0.1,  // clipping near
			 10000.0);  // clipping far

		// Set the drawing position to the center of the scene.
		// then transform it as needed
		const modelViewMatrix = mat4.create();
		
		// this starts with the viewer on this end, and ends with the 
		// science coords on the other end
		
		// how far to step back to, to see it best.  see also trnslate xLength, yLength
		let xLength = this.xPerCell * this.nXCells;  // overall dimensions in science space
		let yLength = this.yPerCell * this.nYCells;
		let zLength = this.zPerCell * this.nZCells;
		mat4.translate(modelViewMatrix,		 // destination matrix
			modelViewMatrix,		 // matrix to translate
			[0, 0, -0.9 * (xLength + yLength)]);
		
		// in cell units but user has rotated it these amounts.
		
		// rotate by latitude
		mat4.rotate(modelViewMatrix,  // destination matrix
			modelViewMatrix,  // matrix to rotate
			π_2 + latitude,   // tip north/south in radians
			[1, 0, 0]);       // around x axis

		// rotate by longitude
		mat4.rotate(modelViewMatrix,  // destination matrix
			modelViewMatrix,  // matrix to rotate
			longitude,   // east-west rotate in radians
			[0, 0, 1]);       // rotate around z

		// cell units go 0...n which isn't symmetric
		// where to slide viewing eye to to, xy, to see it best
		mat4.translate(modelViewMatrix,		 // destination matrix
			modelViewMatrix,		 // matrix to translate
			[-xLength/2, -yLength/2, -zLength / 2]);

		// now using symmetricized xyz coordinates.
		// apply the xPerCell and yPerCell scaling
		mat4.scale(modelViewMatrix, modelViewMatrix, 
			[this.xPerCell, this.yPerCell, this.zPerCell]);
		
		// ok on this end, we're talking science units.

		// Set the shader uniform(s) so glsl programs can get at them
		let uls = this.programInfo.uniformLocations;

		// can't we just put these together on the client so the gpu 
		// doesn't have to multiply every time?
		let compositeMatrix = mat4.create();
		mat4.multiply(compositeMatrix, projectionMatrix, modelViewMatrix);
		Object.assign(this, {compositeMatrix, projectionMatrix, modelViewMatrix});
		
		// maybe this is all we need
		gl.uniformMatrix4fv(uls.compositeMatrix, false, compositeMatrix);
		this.checkOK();
		
		// diagnostic
		//this.verifyMatrices(compositeMatrix);
	}
	
	// longitude and latitude are in radians
	drawOneFrame(longitude, latitude) {
		let gl = this.gl;
		this.longitude = longitude;
		this.latitude = latitude;
		
		// set some gl variables
		gl.clearColor(0.0, 0.0, 0.0, 1.0);	// Clear to black, fully opaque
		gl.clearDepth(1.0);				 // Clear depth buffer (16 bits, distance from viewer)
		gl.enable(gl.DEPTH_TEST);	 // Enable depth testing
		gl.depthFunc(gl.LEQUAL);		// Near things obscure far things
		gl.lineWidth(1.0);
		this.checkOK();

		// Clear the canvas before we start drawing on it.
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		this.checkOK();

		gl.useProgram(this.programInfo.program);
		this.createMatrices(longitude, latitude);
		
		
		// sines and cosines
// 		let fmt = num => num.toFixed(2).padStart(6);
// 		console.log("longitude: l s c       latitude: l s c ", 
// 			fmt(longitude), fmt(Math.sin(longitude)), fmt(Math.cos(longitude)), 
// 			fmt(latitude), fmt(Math.sin(latitude)), fmt(Math.cos(latitude))
// 		);

		// actual drawing
		this.painters.forEach(painter => painter.draw(gl));
	}

}

export default blanketPlot;

